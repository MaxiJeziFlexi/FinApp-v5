# Replit Agent Prompt - Fix FinApp v4 Completely

## Project Context
I have a React financial education app with a beautiful UI but no backend functionality. The frontend is working at https://fin-advisor-maksbraziu.replit.app but all features are just UI shells without actual implementation. I need you to make everything functional.

## Your Mission
Transform this UI-only app into a fully functional financial platform with real backend, database, AI integration, and all advertised features working.

## Step-by-Step Implementation Tasks

### PHASE 1: Backend Infrastructure Setup

1. **Create Express Server**
```bash
mkdir -p server/routes server/controllers server/middleware server/db server/utils
```

Create `server/index.js`:
```javascript
const express = require('express');
const cors = require('cors');
const session = require('express-session');
const bcrypt = require('bcryptjs');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? 'https://fin-advisor-maksbraziu.replit.app'
    : 'http://localhost:5173',
  credentials: true
}));
app.use(express.json());
app.use(session({
  secret: process.env.SESSION_SECRET || 'dev-secret-change-in-production',
  resave: false,
  saveUninitialized: false,
  cookie: { 
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 24 * 60 * 60 * 1000 // 24 hours
  }
}));

// Serve static files in production
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../dist')));
}

// Import routes (create these next)
const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const aiRoutes = require('./routes/ai');
const cryptoRoutes = require('./routes/crypto');
const gameRoutes = require('./routes/game');
const taxRoutes = require('./routes/tax');

// API routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/ai', aiRoutes);
app.use('/api/crypto', cryptoRoutes);
app.use('/api/game', gameRoutes);
app.use('/api/tax', taxRoutes);

// Catch-all route for React app
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../dist/index.html'));
});

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

2. **Install ALL Required Dependencies**
```bash
npm install express cors bcryptjs express-session dotenv
npm install postgres drizzle-orm
npm install openai
npm install jsonwebtoken
npm install express-rate-limit
npm install morgan
npm install zod
npm install concurrently nodemon --save-dev
```

### PHASE 2: Database Setup with Drizzle ORM

3. **Create Database Schema**
Create `server/db/schema.js`:
```javascript
import { pgTable, serial, text, varchar, timestamp, integer, boolean, decimal, json } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: text('password_hash').notNull(),
  username: varchar('username', { length: 100 }),
  fullName: varchar('full_name', { length: 255 }),
  profileImage: text('profile_image'),
  role: varchar('role', { length: 50 }).default('user'),
  profileCompleted: boolean('profile_completed').default(false),
  profileData: json('profile_data'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

export const transactions = pgTable('transactions', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  type: varchar('type', { length: 50 }),
  amount: decimal('amount', { precision: 10, scale: 2 }),
  cryptoAmount: decimal('crypto_amount', { precision: 18, scale: 8 }),
  description: text('description'),
  status: varchar('status', { length: 50 }).default('pending'),
  createdAt: timestamp('created_at').defaultNow()
});

export const achievements = pgTable('achievements', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  type: varchar('type', { length: 100 }),
  title: varchar('title', { length: 255 }),
  description: text('description'),
  points: integer('points').default(0),
  unlockedAt: timestamp('unlocked_at').defaultNow()
});

export const aiReports = pgTable('ai_reports', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  reportType: varchar('report_type', { length: 100 }),
  content: json('content'),
  insights: json('insights'),
  createdAt: timestamp('created_at').defaultNow()
});

export const challenges = pgTable('challenges', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 255 }),
  description: text('description'),
  difficulty: varchar('difficulty', { length: 50 }),
  rewardPoints: integer('reward_points'),
  rewardCrypto: decimal('reward_crypto', { precision: 18, scale: 8 }),
  category: varchar('category', { length: 100 }),
  ageGroup: varchar('age_group', { length: 50 }),
  active: boolean('active').default(true)
});

export const userProgress = pgTable('user_progress', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  challengeId: integer('challenge_id').references(() => challenges.id),
  progress: integer('progress').default(0),
  completed: boolean('completed').default(false),
  completedAt: timestamp('completed_at'),
  startedAt: timestamp('started_at').defaultNow()
});

export const financialGoals = pgTable('financial_goals', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  goalType: varchar('goal_type', { length: 100 }),
  targetAmount: decimal('target_amount', { precision: 12, scale: 2 }),
  currentAmount: decimal('current_amount', { precision: 12, scale: 2 }).default('0'),
  deadline: timestamp('deadline'),
  createdAt: timestamp('created_at').defaultNow()
});
```

4. **Create Database Configuration**
Create `server/db/config.js`:
```javascript
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema.js';

const connectionString = process.env.DATABASE_URL || 'postgresql://localhost:5432/finapp';
const sql = postgres(connectionString);
export const db = drizzle(sql, { schema });
```

5. **Create Drizzle Config**
Create `drizzle.config.ts`:
```typescript
import type { Config } from 'drizzle-kit';

export default {
  schema: './server/db/schema.js',
  out: './drizzle',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
} satisfies Config;
```

### PHASE 3: Authentication System

6. **Create Auth Routes**
Create `server/routes/auth.js`:
```javascript
const express = require('express');
const bcrypt = require('bcryptjs');
const router = express.Router();
const { db } = require('../db/config');
const { users } = require('../db/schema');
const { eq } = require('drizzle-orm');

// Register
router.post('/register', async (req, res) => {
  try {
    const { email, password, username } = req.body;
    
    // Check if user exists
    const existingUser = await db.select().from(users).where(eq(users.email, email));
    if (existingUser.length > 0) {
      return res.status(400).json({ error: 'User already exists' });
    }
    
    // Hash password
    const passwordHash = await bcrypt.hash(password, 12);
    
    // Create user
    const newUser = await db.insert(users).values({
      email,
      passwordHash,
      username
    }).returning();
    
    // Create session
    req.session.userId = newUser[0].id;
    req.session.userEmail = newUser[0].email;
    
    res.json({ 
      success: true, 
      user: { 
        id: newUser[0].id, 
        email: newUser[0].email,
        username: newUser[0].username 
      } 
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    // Find user
    const user = await db.select().from(users).where(eq(users.email, email));
    if (user.length === 0) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Check password
    const validPassword = await bcrypt.compare(password, user[0].passwordHash);
    if (!validPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    
    // Create session
    req.session.userId = user[0].id;
    req.session.userEmail = user[0].email;
    
    res.json({ 
      success: true, 
      user: { 
        id: user[0].id, 
        email: user[0].email,
        username: user[0].username,
        profileCompleted: user[0].profileCompleted 
      } 
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Logout
router.post('/logout', (req, res) => {
  req.session.destroy();
  res.json({ success: true });
});

// Check session
router.get('/me', async (req, res) => {
  if (!req.session.userId) {
    return res.status(401).json({ error: 'Not authenticated' });
  }
  
  const user = await db.select().from(users).where(eq(users.id, req.session.userId));
  res.json({ user: user[0] });
});

module.exports = router;
```

### PHASE 4: AI Integration

7. **Create AI Routes with OpenAI**
Create `server/routes/ai.js`:
```javascript
const express = require('express');
const router = express.Router();
const OpenAI = require('openai');
const { db } = require('../db/config');
const { aiReports, users } = require('../db/schema');
const { requireAuth } = require('../middleware/auth');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Generate Financial Report
router.post('/generate-report', requireAuth, async (req, res) => {
  try {
    const { reportType, userData } = req.body;
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are a financial advisor AI. Generate detailed, personalized financial reports."
        },
        {
          role: "user",
          content: `Generate a ${reportType} report for user with data: ${JSON.stringify(userData)}`
        }
      ]
    });
    
    const reportContent = completion.choices[0].message.content;
    
    // Save to database
    const report = await db.insert(aiReports).values({
      userId: req.session.userId,
      reportType,
      content: { text: reportContent, data: userData },
      insights: { generated: new Date() }
    }).returning();
    
    res.json({ success: true, report: report[0] });
  } catch (error) {
    console.error('AI Report generation error:', error);
    res.status(500).json({ error: 'Failed to generate report' });
  }
});

// Investment Advice
router.post('/investment-advice', requireAuth, async (req, res) => {
  try {
    const { riskProfile, investmentGoals, currentPortfolio } = req.body;
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are an expert investment advisor. Provide personalized investment strategies."
        },
        {
          role: "user",
          content: `Risk Profile: ${riskProfile}, Goals: ${investmentGoals}, Current Portfolio: ${JSON.stringify(currentPortfolio)}`
        }
      ]
    });
    
    res.json({ 
      success: true, 
      advice: completion.choices[0].message.content 
    });
  } catch (error) {
    console.error('Investment advice error:', error);
    res.status(500).json({ error: 'Failed to generate advice' });
  }
});

// Tax Optimization (Spectrum Tax Analysis)
router.post('/tax-optimization', requireAuth, async (req, res) => {
  try {
    const { income, deductions, filingStatus } = req.body;
    
    // Implement 2025 tax calculations
    const taxBrackets2025 = {
      single: [
        { min: 0, max: 11600, rate: 0.10 },
        { min: 11600, max: 47150, rate: 0.12 },
        { min: 47150, max: 100525, rate: 0.22 },
        { min: 100525, max: 191950, rate: 0.24 },
        { min: 191950, max: 243725, rate: 0.32 },
        { min: 243725, max: 609350, rate: 0.35 },
        { min: 609350, max: Infinity, rate: 0.37 }
      ]
    };
    
    // Calculate tax
    let tax = 0;
    let taxableIncome = income - deductions;
    const brackets = taxBrackets2025[filingStatus] || taxBrackets2025.single;
    
    for (const bracket of brackets) {
      if (taxableIncome > bracket.min) {
        const taxableInBracket = Math.min(taxableIncome - bracket.min, bracket.max - bracket.min);
        tax += taxableInBracket * bracket.rate;
      }
    }
    
    // Get AI optimization suggestions
    const completion = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are a tax optimization expert. Provide strategies to minimize tax liability legally."
        },
        {
          role: "user",
          content: `Income: $${income}, Current Tax: $${tax.toFixed(2)}, Filing Status: ${filingStatus}`
        }
      ]
    });
    
    res.json({
      success: true,
      currentTax: tax.toFixed(2),
      effectiveRate: ((tax / income) * 100).toFixed(2),
      optimizationStrategies: completion.choices[0].message.content
    });
  } catch (error) {
    console.error('Tax optimization error:', error);
    res.status(500).json({ error: 'Failed to optimize taxes' });
  }
});

module.exports = router;
```

### PHASE 5: Gamification System

8. **Create Gamification Routes**
Create `server/routes/game.js`:
```javascript
const express = require('express');
const router = express.Router();
const { db } = require('../db/config');
const { achievements, challenges, userProgress, users } = require('../db/schema');
const { eq, and } = require('drizzle-orm');
const { requireAuth } = require('../middleware/auth');

// Get user achievements
router.get('/achievements', requireAuth, async (req, res) => {
  try {
    const userAchievements = await db.select()
      .from(achievements)
      .where(eq(achievements.userId, req.session.userId));
    
    res.json({ achievements: userAchievements });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch achievements' });
  }
});

// Unlock achievement
router.post('/achievements/unlock', requireAuth, async (req, res) => {
  try {
    const { type, title, description, points } = req.body;
    
    // Check if already unlocked
    const existing = await db.select()
      .from(achievements)
      .where(and(
        eq(achievements.userId, req.session.userId),
        eq(achievements.type, type)
      ));
    
    if (existing.length > 0) {
      return res.json({ alreadyUnlocked: true, achievement: existing[0] });
    }
    
    // Unlock new achievement
    const achievement = await db.insert(achievements).values({
      userId: req.session.userId,
      type,
      title,
      description,
      points
    }).returning();
    
    // Update user points
    // Add logic to update user's total points
    
    res.json({ success: true, achievement: achievement[0] });
  } catch (error) {
    res.status(500).json({ error: 'Failed to unlock achievement' });
  }
});

// Get available challenges
router.get('/challenges', requireAuth, async (req, res) => {
  try {
    const allChallenges = await db.select().from(challenges).where(eq(challenges.active, true));
    
    // Get user's progress
    const userProgressData = await db.select()
      .from(userProgress)
      .where(eq(userProgress.userId, req.session.userId));
    
    const challengesWithProgress = allChallenges.map(challenge => {
      const progress = userProgressData.find(p => p.challengeId === challenge.id);
      return {
        ...challenge,
        userProgress: progress || { progress: 0, completed: false }
      };
    });
    
    res.json({ challenges: challengesWithProgress });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch challenges' });
  }
});

// Update challenge progress
router.post('/challenges/:id/progress', requireAuth, async (req, res) => {
  try {
    const challengeId = parseInt(req.params.id);
    const { progress } = req.body;
    
    // Check if progress exists
    const existing = await db.select()
      .from(userProgress)
      .where(and(
        eq(userProgress.userId, req.session.userId),
        eq(userProgress.challengeId, challengeId)
      ));
    
    if (existing.length > 0) {
      // Update existing progress
      const updated = await db.update(userProgress)
        .set({ 
          progress,
          completed: progress >= 100,
          completedAt: progress >= 100 ? new Date() : null
        })
        .where(and(
          eq(userProgress.userId, req.session.userId),
          eq(userProgress.challengeId, challengeId)
        ))
        .returning();
      
      res.json({ success: true, progress: updated[0] });
    } else {
      // Create new progress
      const newProgress = await db.insert(userProgress).values({
        userId: req.session.userId,
        challengeId,
        progress,
        completed: progress >= 100,
        completedAt: progress >= 100 ? new Date() : null
      }).returning();
      
      res.json({ success: true, progress: newProgress[0] });
    }
    
    // If completed, award rewards
    if (progress >= 100) {
      const challenge = await db.select().from(challenges).where(eq(challenges.id, challengeId));
      if (challenge[0]) {
        // Award points and crypto
        // Implement reward distribution logic here
      }
    }
  } catch (error) {
    res.status(500).json({ error: 'Failed to update progress' });
  }
});

// Get leaderboard
router.get('/leaderboard', async (req, res) => {
  try {
    // Implement leaderboard logic
    // Join users with their total points from achievements
    const leaderboard = await db.execute`
      SELECT u.id, u.username, u.profile_image, 
             COALESCE(SUM(a.points), 0) as total_points
      FROM users u
      LEFT JOIN achievements a ON u.id = a.user_id
      GROUP BY u.id, u.username, u.profile_image
      ORDER BY total_points DESC
      LIMIT 100
    `;
    
    res.json({ leaderboard });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch leaderboard' });
  }
});

module.exports = router;
```

### PHASE 6: Crypto Marketplace

9. **Create Crypto Routes**
Create `server/routes/crypto.js`:
```javascript
const express = require('express');
const router = express.Router();
const { db } = require('../db/config');
const { transactions, users } = require('../db/schema');
const { eq } = require('drizzle-orm');
const { requireAuth } = require('../middleware/auth');

// Get user's crypto balance
router.get('/balance', requireAuth, async (req, res) => {
  try {
    const userTransactions = await db.select()
      .from(transactions)
      .where(eq(transactions.userId, req.session.userId));
    
    // Calculate balance
    let balance = 0;
    userTransactions.forEach(tx => {
      if (tx.type === 'earn' || tx.type === 'deposit') {
        balance += parseFloat(tx.cryptoAmount || 0);
      } else if (tx.type === 'spend' || tx.type === 'withdraw') {
        balance -= parseFloat(tx.cryptoAmount || 0);
      }
    });
    
    res.json({ balance, transactions: userTransactions });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch balance' });
  }
});

// P2P marketplace listing
router.get('/marketplace', async (req, res) => {
  try {
    // Implement marketplace listings
    // This would fetch advice/services being offered
    const listings = [
      {
        id: 1,
        title: "Tax Optimization Consultation",
        seller: "Expert123",
        price: 0.005,
        rating: 4.8,
        reviews: 127
      },
      {
        id: 2,
        title: "Investment Portfolio Review",
        seller: "FinanceGuru",
        price: 0.008,
        rating: 4.9,
        reviews: 89
      }
    ];
    
    res.json({ listings });
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch marketplace' });
  }
});

// Create transaction
router.post('/transaction', requireAuth, async (req, res) => {
  try {
    const { type, amount, cryptoAmount, description } = req.body;
    
    const transaction = await db.insert(transactions).values({
      userId: req.session.userId,
      type,
      amount,
      cryptoAmount,
      description,
      status: 'completed'
    }).returning();
    
    res.json({ success: true, transaction: transaction[0] });
  } catch (error) {
    res.status(500).json({ error: 'Failed to create transaction' });
  }
});

module.exports = router;
```

### PHASE 7: Frontend Integration

10. **Create API Client**
Create `src/lib/api.ts`:
```typescript
const API_URL = import.meta.env.VITE_API_URL || '';

class APIClient {
  private async request(endpoint: string, options: RequestInit = {}) {
    const response = await fetch(`${API_URL}/api${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      credentials: 'include',
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    
    return response.json();
  }
  
  // Auth methods
  auth = {
    login: (email: string, password: string) => 
      this.request('/auth/login', {
        method: 'POST',
        body: JSON.stringify({ email, password })
      }),
    
    register: (data: any) => 
      this.request('/auth/register', {
        method: 'POST',
        body: JSON.stringify(data)
      }),
    
    logout: () => 
      this.request('/auth/logout', { method: 'POST' }),
    
    getMe: () => 
      this.request('/auth/me')
  };
  
  // AI methods
  ai = {
    generateReport: (reportType: string, userData: any) =>
      this.request('/ai/generate-report', {
        method: 'POST',
        body: JSON.stringify({ reportType, userData })
      }),
    
    getInvestmentAdvice: (data: any) =>
      this.request('/ai/investment-advice', {
        method: 'POST',
        body: JSON.stringify(data)
      }),
    
    optimizeTax: (data: any) =>
      this.request('/ai/tax-optimization', {
        method: 'POST',
        body: JSON.stringify(data)
      })
  };
  
  // Game methods
  game = {
    getAchievements: () =>
      this.request('/game/achievements'),
    
    unlockAchievement: (data: any) =>
      this.request('/game/achievements/unlock', {
        method: 'POST',
        body: JSON.stringify(data)
      }),
    
    getChallenges: () =>
      this.request('/game/challenges'),
    
    updateProgress: (challengeId: number, progress: number) =>
      this.request(`/game/challenges/${challengeId}/progress`, {
        method: 'POST',
        body: JSON.stringify({ progress })
      }),
    
    getLeaderboard: () =>
      this.request('/game/leaderboard')
  };
  
  // Crypto methods
  crypto = {
    getBalance: () =>
      this.request('/crypto/balance'),
    
    getMarketplace: () =>
      this.request('/crypto/marketplace'),
    
    createTransaction: (data: any) =>
      this.request('/crypto/transaction', {
        method: 'POST',
        body: JSON.stringify(data)
      })
  };
}

export const api = new APIClient();
```

11. **Create Auth Hook**
Create `src/hooks/useAuth.ts`:
```typescript
import { create } from 'zustand';
import { api } from '../lib/api';

interface User {
  id: number;
  email: string;
  username: string;
  profileCompleted: boolean;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<void>;
  register: (data: any) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

export const useAuth = create<AuthState>((set) => ({
  user: null,
  isLoading: false,
  error: null,
  
  login: async (email, password) => {
    set({ isLoading: true, error: null });
    try {
      const response = await api.auth.login(email, password);
      set({ user: response.user, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },
  
  register: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const response = await api.auth.register(data);
      set({ user: response.user, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
      throw error;
    }
  },
  
  logout: async () => {
    try {
      await api.auth.logout();
      set({ user: null });
    } catch (error) {
      console.error('Logout error:', error);
    }
  },
  
  checkAuth: async () => {
    try {
      const response = await api.auth.getMe();
      set({ user: response.user });
    } catch (error) {
      set({ user: null });
    }
  }
}));
```

### PHASE 8: Environment & Configuration

12. **Update package.json scripts**:
```json
{
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "dev:client": "vite",
    "dev:server": "nodemon server/index.js",
    "build": "vite build",
    "start": "NODE_ENV=production node server/index.js",
    "db:generate": "drizzle-kit generate:pg",
    "db:push": "drizzle-kit push:pg",
    "db:studio": "drizzle-kit studio"
  }
}
```

13. **Add to Replit Secrets** (CRITICAL):
```
DATABASE_URL=postgresql://[get-from-neon-dashboard]
OPENAI_API_KEY=sk-[your-openai-key]
SESSION_SECRET=your-super-secret-session-key-minimum-32-chars-long
VITE_API_URL=https://fin-advisor-maksbraziu.replit.app
NODE_ENV=production
```

14. **Update .replit file**:
```
run = "npm run build && npm run start"
hidden = [".config", "package-lock.json"]
entrypoint = "server/index.js"

[languages.javascript]
pattern = "**/{*.js,*.jsx,*.ts,*.tsx}"
syntax = "javascript"

[env]
XDG_CONFIG_HOME = "/home/runner/$REPL_SLUG/.config"

[nix]
channel = "stable-24_05"

[deployment]
run = ["sh", "-c", "npm run build && npm run start"]
deploymentTarget = "cloudrun"
```

### PHASE 9: Initialize Database

15. **Create seed file** `server/db/seed.js`:
```javascript
import { db } from './config.js';
import { challenges } from './schema.js';

async function seed() {
  // Add sample challenges
  await db.insert(challenges).values([
    {
      title: "First Steps",
      description: "Complete your profile",
      difficulty: "easy",
      rewardPoints: 100,
      rewardCrypto: "0.001",
      category: "onboarding",
      ageGroup: "all"
    },
    {
      title: "Budget Master",
      description: "Create your first budget",
      difficulty: "medium",
      rewardPoints: 250,
      rewardCrypto: "0.002",
      category: "finance",
      ageGroup: "all"
    },
    {
      title: "Investment Rookie",
      description: "Learn about 5 investment types",
      difficulty: "medium",
      rewardPoints: 300,
      rewardCrypto: "0.003",
      category: "education",
      ageGroup: "adult"
    }
  ]);
  
  console.log('Database seeded!');
}

seed();
```

### PHASE 10: Testing & Fixes

16. **Test each endpoint manually and fix any issues**
17. **Ensure all frontend pages connect to backend**
18. **Add proper error handling everywhere**
19. **Implement loading states in UI**
20. **Add form validation**

## IMPORTANT NOTES FOR REPLIT AGENT:

1. **Database First**: Sign up for Neon Database (free tier) and add DATABASE_URL to Secrets
2. **OpenAI Key**: Get from OpenAI platform and add to Secrets
3. **Install Dependencies**: Run all npm install commands
4. **Create All Files**: Follow the exact file structure
5. **Test Authentication**: Make sure login/register works before moving to other features
6. **Incremental Testing**: Test each feature as you build it
7. **Use ES Modules**: Some files use import/export, configure package.json with "type": "module" if needed
8. **CORS Issues**: Make sure CORS is properly configured for your Replit URL
9. **Session Secret**: Generate a strong 32+ character secret for production
10. **Error Handling**: Add try-catch blocks everywhere

## Final Checklist:
- [ ] Backend server running
- [ ] Database connected and tables created
- [ ] Authentication working (login/register/logout)
- [ ] AI features generating reports
- [ ] Gamification tracking achievements
- [ ] Crypto balance updating
- [ ] All API endpoints returning data
- [ ] Frontend consuming real API data
- [ ] Profile completion percentage calculating correctly
- [ ] Admin panel functional

Start with Phase 1 and work through each phase sequentially. Test everything as you go!